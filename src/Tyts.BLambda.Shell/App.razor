@using System.Reflection;
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication;
@using Microsoft.AspNetCore.Components.WebAssembly.Services;
@using Microsoft.AspNetCore.WebUtilities;
@using Microsoft.Extensions.Logging;
@using Microsoft.Extensions.Options;
@using Tyts.BLambda.Blazor.Application.Module;
@using Tyts.BLambda.Blazor.Application.Template
@using Tyts.BLambda.Blazor.Theme;
@using Tyts.BLambda.Shell.Authentication;

<FluentDesignTheme StorageName="theme" />
<Router AppAssembly="@typeof(App).Assembly" AdditionalAssemblies="@assemblies">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@Template.Current.GetLayout(isAuthenticated)">
            <Authorizing>
                <text>@ProcessingMessage</text>
            </Authorizing>
            <NotAuthorized>
                @if (!isAuthenticated) //context.User.Identity?.IsAuthenticated != true
                {
                    // 401 UNAUTHORIZED?
                    <p>Welcome!</p>
                    <FluentButton Appearance="Appearance.Outline" @onclick="LogIn">Login</FluentButton>
                }
                else
                {
                    // 403 FORBIDDEN?
                    <p role="alert">You are not authorized to access this resource.</p>
                }
            </NotAuthorized>                
        </AuthorizeRouteView>
        @*<FocusOnNavigate RouteData="@routeData" Selector="h1" />*@
    </Found>
    <NotFound>
        <PageTitle>Not found</PageTitle>
        <LayoutView Layout="@Template.Current.GetLayout(isAuthenticated)">
            <p role="alert">@(modulesLoaded ? "Sorry, there's nothing at this address." : "Loading modules..")</p>
        </LayoutView>
    </NotFound>
</Router>



@inject IModulService ModuleService
@inject ITemplateService Template
@inject ILogger<App> Logger
@inject NavigationManager Navigation
@inject IOptionsSnapshot<RemoteAuthenticationOptions<ApiAuthorizationProviderOptions>> Options
@inject AuthenticationStateProvider AuthStateProvider
@inject CognitoHelper CognitoHelper
@*RemoteAuthenticationService*@ 

@implements IDisposable
@code {
    List<Assembly> assemblies = new();
    bool isAuthenticated = false;
    bool isLoggingOut = false;
    bool modulesLoaded = false;

    string ProcessingMessage => isLoggingOut ? "Please wait, we are logging out..." : "Please wait, we are authorizing...";

    [Parameter]
    public string ReturnUrl { get; set; } = "/";


    protected override async Task OnInitializedAsync()
    {
        var state = await AuthStateProvider.GetAuthenticationStateAsync();
        isAuthenticated = state.User.Identity?.IsAuthenticated ?? false;

        var loggedOutPath = Options.Get(Microsoft.Extensions.Options.Options.DefaultName).AuthenticationPaths.LogOutSucceededPath;
        isLoggingOut = Navigation.Uri.Contains(loggedOutPath, StringComparison.OrdinalIgnoreCase);

        AuthStateProvider.AuthenticationStateChanged += App_AuthenticationStateChanged;
        ModuleService.ModuleLoaded += App_ModuleLoaded;
        Navigation.LocationChanged += App_LocationChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ModuleService.EnsureNotLazyModulesLoaded();
            modulesLoaded = true;
        }        
    }

    void LogIn()
    {
        var loginPath = Options.Get(Microsoft.Extensions.Options.Options.DefaultName).AuthenticationPaths.LogInPath;
        Navigation.NavigateToLogin(loginPath, new InteractiveRequestOptions
        {
            ReturnUrl = ReturnUrl,
            Interaction = InteractionType.SignIn
        });
    }

    void App_LocationChanged(object? sender, LocationChangedEventArgs args)
    {        
        //TODO: instead detect auth state changing in another tab

        //var state = await AuthStateProvider.GetAuthenticationStateAsync();
        //var newIsAuthenticated = state.User.Identity?.IsAuthenticated ?? false;
        var newIsAuthenticated = CognitoHelper.IdentityIsAuthenticated();

        if (isAuthenticated != newIsAuthenticated)
        {
            var isAuthenticating = Navigation.Uri.StartsWith($"{Navigation.BaseUri}authentication/", StringComparison.OrdinalIgnoreCase);
            if (!newIsAuthenticated && !isAuthenticating) // was logged out implicitly
            {
                var logOutPath = Options.Get(Microsoft.Extensions.Options.Options.DefaultName).AuthenticationPaths.LogOutSucceededPath;
                var returnUrl = Uri.EscapeDataString(Navigation.ToBaseRelativePath(Navigation.Uri));
                if (!string.IsNullOrEmpty(returnUrl))
                {
                    logOutPath = QueryHelpers.AddQueryString(logOutPath, "returnUrl", returnUrl);
                }

                Navigation.NavigateTo(logOutPath, replace: true);
            }

            isAuthenticated = newIsAuthenticated;
            StateHasChanged();
        }
    }

    async void App_AuthenticationStateChanged(Task<AuthenticationState> getAuthenticationState)
    {
        var state = await getAuthenticationState;
        isAuthenticated = state.User.Identity?.IsAuthenticated ?? false;
    }

    async void App_ModuleLoaded(string name)
    {
        var assembly = (await ModuleService.GetModule(name)).Assembly;
        if (assembly is not null)
        {
            this.assemblies.Add(assembly);
            modulesLoaded = true;
            StateHasChanged();
        }
    }

    void IDisposable.Dispose()
    {
        ModuleService.ModuleLoaded -= App_ModuleLoaded;
        AuthStateProvider.AuthenticationStateChanged -= App_AuthenticationStateChanged;
        Navigation.LocationChanged -= App_LocationChanged;
    }
}